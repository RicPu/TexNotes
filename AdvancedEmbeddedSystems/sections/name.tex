\section{Processors}
The performance of a Central Processing Unit (CPU), or microprocessor, can be
quantified by the time it takes to execute a program. This time is
fundamentally influenced by three key factors:

\begin{enumerate}
    \item \textbf{Instruction Count (IC)}: This is the total number of instructions a program executes. It's determined primarily by the Instruction Set Architecture (ISA) - the set of operations the CPU can understand - and the compiler that translates high-level code into machine instructions. A more complex ISA or an inefficient compiler might result in a higher instruction count for the same task.

    \item \textbf{Cycles Per Instruction (CPI)}: This is the average number of clock cycles required to execute a single instruction. Different instructions take different amounts of time (cycles) to complete.

    \item \textbf{Cycle Time (\(\tau\))}: Also known as the clock period, this is the time duration of one clock cycle, usually measured in seconds. The inverse of the cycle time is the clock rate or frequency (measured in Hertz, Hz), which is often the figure used to market CPUs (e.g., \SI{3.0}{\hertz}).
\end{enumerate}

The overall execution time (\(T\)) for a program can be mathematically
expressed as:

\begin{equation}
    T = \text{IC} \times \text{CPI} \times \tau
\end{equation}

While the Instruction Count is mainly determined by the ISA and compiler, the
CPI and Cycle Time are primarily determined by the CPU hardware implementation.
Designers aim to minimize all three factors for better performance.

\paragraph{Simplified MIPS Instruction Subset} To illustrate the concepts, we'll focus on a simple subset of MIPS instructions
that demonstrates most aspects of CPU operation:

\begin{itemize}
    \item \textbf{Memory Reference}:
          \begin{itemize}
              \item \NewTexttt{lw} (load word): Loads data from memory into a register.
              \item \NewTexttt{sw} (store word): Store data from a register into memory.
          \end{itemize}

    \item \textbf{Arithmetic/Logical}:
          \begin{itemize}
              \item \NewTexttt{add}, \NewTexttt{sub}: Addition and subtraction.
              \item \NewTexttt{and}, \NewTexttt{or}: Bitwise logical operations.
              \item \NewTexttt{slt} (set on less than): Comparison operations.
          \end{itemize}

    \item \textbf{Control Transfer}:
          \begin{itemize}
              \item \NewTexttt{beq} (branch if equal): Changes the program flow based on a condition.
              \item \NewTexttt{j} (jump): Unconditional change of program flow.
          \end{itemize}
\end{itemize}

\subsection{The Execution Cycle: Fundamental Steps}
Every instruction, regardless of type, must pass through a sequence of
fundamental steps to be executed by the CPU hardware:

\begin{enumerate}
    \item \textbf{Instruction Fetch}: The address stored in the Program Counter (PC) is sent to the Instruction Memory to fetch the instruction.

    \item \textbf{Register Decode/Read}: The instruction's register numbers are extracted and sent to the Register File to read the values of the source registers.

    \item \textbf{Execution}: The Arithmetic Logic Unit (ALU) is used to calculate the required result:
          \begin{itemize}
              \item Arithmetic Result: for \NewTexttt{add}, \NewTexttt{sub}, etc.
              \item Memory Address: for \NewTexttt{lw} or \NewTexttt{sw}, the ALU calculates the
                    effective memory address (base address + offset).
              \item Branch Target Address: for \NewTexttt{beq}, the ALu calculates the address to
                    jump to if the branch condition is met.
          \end{itemize}

    \item \textbf{Memory Access (Load/Store Instructions Only)}: Data Memory is accessed only for \NewTexttt{lw} (to read data) or \NewTexttt{sw} (to write data).

    \item \textbf{Write Back/PC Update}: Write Back the result (e.g., from ALU or memory load) is updated for the next instruction. The Program Counter is updated for the next instruction:
          \begin{itemize}
              \item For sequential execution, PC \(\leftarrow\) PC + 4 (since MIPS instructions are
                    4 bytes).
              \item For control transfer (\NewTexttt{beq}, \NewTexttt{j}), PC \(\leftarrow\) Target
                    Address.
          \end{itemize}
\end{enumerate}

\paragraph{Digital Information and Encoding.} All information within a microprocessor is represented and processed using
binary code. Low voltage typically represents a logic 0, while High voltage
typically represents a logic 1. A single binary digit is called a bit. One wire
is dedicated to carrying the signal for a single bit. Data composed of multiple
bits (e.g., 32-bit or 64-bit words) is encoded on multi-wire buses, where each
wire in the bus corresponds to one bit of the data word.

\paragraph{Combinational Elements.} Combinational elements are the "calculators" of the CPU. Their core function is
to operate on input data and produce an output that is purely a function of the
current input values. They do not have memory or state. They transform and
operate on data. Examples include basic logic gates (AND, OR, NOT) and complex
structures like the Arithmetic Logic Unit (ALU). The output is always and
immediately a function of the input. If the input changes, the output changes
instantly (subject to small physical signal delays). These elements perform
their transformations between clock edges - the time during which data is being
processed before being captured by the next state element.

\paragraph{Sequential Elements.} State (sequential) elements are the "memory" units of the CPU. Unlike
combinational logic, they store information and are crucial for maintaining the
"state" of the system over time. A fundamental state element is the register, a
small, high-speed circuit that stores a data word:

\begin{itemize}
    \item \textbf{Clock Signal}: Registers are governed by a clock signal (\NewTexttt{Clk}), a periodic signal that dictates when the stored value can be updated. This synchronization is critical for orderly data movement.
    \item \textbf{Edge-Triggered Update}: Most registers are edge-triggered. This means the stored data is only updated at a specific moment - typically when the Clock signal changes from 0 to 1 (rising edge). This ensures data is captured synchronously across the entire CPU.
\end{itemize}

To allow the stored value to be retained across multiple clock cycles when an
update isn't needed, registers often incorporate a write control input. The
stored value only updates on the clock edge if and only if the write control
input is simultaneously set to 1 (active). This control is essential because
not all results need to be written back to a register on every cycle. It
prevents unnecessary changes, ensuring the stored value is available for later
use by other parts of the circuit.

\paragraph{Clock Cycles and Performance.} The interaction between combinational and state elements defines the CPU's
timing and maximum performance:

\begin{itemize}
    \item \textbf{Data Flow}: Data moves from one state element (register) \(\rightarrow\) through combinational logic (ALU) \(\rightarrow\) to the next state element (register).
    \item \textbf{Timing Constraint}: The data transformation must be complete before the next clock edge arrives. Therefore, the longest delay through any combinational logic path in the entire circuit determines the minimum possible clock period (\(\tau\)).
    \item \textbf{Clock Period}: The CPU's clock period (\(\tau\)) must be set slightly longer than this longest delay to ensure all signals stabilize and valid data is ready for capture by the registers on the next clock edge.
\end{itemize}

\begin{figure}[!b]
    \centering
    \begin{tikzpicture}[scale=0.75, transform shape]
        \node[instr_mem, anchor=lpin 1, align=center] (INSTR_MEM) {\\[12mm]Instruction\\Memory};
        \node[RF, anchor=lpin 1, xshift=1cm] (RF) at (INSTR_MEM.rpin 1) {Registers};
        \node[ALU, anchor=lpin 1, xshift=1cm] (ALU) at (RF.rpin 2) {ALU};
        \node[mux2to1, anchor=lpin 1, xshift=0.5cm, align=center] (MUX1) at (RF.rpin 3) {M\\U\\X};
        \node[data_mem, anchor=lpin 1, align=center] (DATA_MEM) at (ALU.rpin 1) {Data\\Memory};
        \node[extend, yshift=-1cm] (EXTEND) at (RF.south) {Sign-Extender};
        \node[ALU, anchor=lpin 1, yshift=4cm] (ADD1) at (ALU.lpin 1) {ADD};
        \node[mux2to1, anchor=lpin 2, align=center] (MUX2) at (ADD1.rpin 1) {M\\U\\X};
        \node[ALU, anchor=rpin 1, xshift=-4cm] (ADD2) at (ADD1.lpin 1) {ADD};
        \node[mux2to1, anchor=lpin 1, align=center, xshift=0.5cm] (MUX3) at (DATA_MEM.rpin 3) {M\\U\\X};
        \node[ff_we, anchor=rpin 1, xshift=-0.5cm] (PC) at (INSTR_MEM.lpin 1) {PC};
        \node[ff_we, anchor=rpin 1, xshift=-0.5cm, align=center] (SL2) at (ADD1.lpin 2) {Shift\\Left 2};

        \coordinate (IM-R) at ($(INSTR_MEM.brpin 1)!0.5!(RF.blpin 1)$);
        \coordinate (R-MUX) at ($(RF.brpin 4)!0.5!(MUX1.blpin 2)$);
        \coordinate (A-DM) at ($(ALU.brpin 1)!0.5!(DATA_MEM.blpin 1)$);
        \coordinate (MID1) at ($(IM-R)!0.5!(RF.blpin 4)+(0, -5)$);
        \coordinate (MID2) at ($(R-MUX)!0.5!(RF.brpin 3)$);
        \coordinate (PC-A) at ($(PC.brpin 1)!0.5!(INSTR_MEM.blpin 1)$);

        \draw[very thick]
        (INSTR_MEM.brpin 1) -- (RF.blpin 1)
        (IM-R) |- (RF.blpin 2)
        (IM-R) |- (RF.blpin 3)
        (IM-R) |- (EXTEND.blpin 1)
        (RF.brpin 2) -- (ALU.blpin 1)
        (RF.brpin 3) -- (MUX1.blpin 1)
        (MUX1.brpin 1) -- (ALU.blpin 2)
        (ALU.brpin 1) -- (DATA_MEM.blpin 1)
        (R-MUX) |- (MUX1.blpin 2)
        (ADD1.brpin 1) -- (MUX2.blpin 2)
        (ADD2.brpin 1) -- (ADD1.blpin 1)
        (DATA_MEM.brpin 3) -- (MUX3.blpin 1)
        (MUX3.blpin 2) -| (A-DM)
        (RF.blpin 4) -| (MID1) -- ++(13.25, 0) |- (MUX3.brpin 1)
        (RF.brpin 3) -| (MID2) |- (DATA_MEM.blpin 3)
        (ADD1.blpin 1) -| ++(-1, 1) -- ++(3, 0) |- (MUX2.blpin 1)
        (PC.brpin 1) -- (INSTR_MEM.blpin 1)
        (PC-A) |- (ADD2.blpin 1)
        (MUX2.brpin 1) -- (MUX2.rpin 1) |- ++(-15, 2) -| (PC.lpin 1) -- (PC.blpin 1)
        (EXTEND.brpin 1) -| (R-MUX) |- (SL2.lpin 1) -- (SL2.blpin 1)
        (SL2.brpin 1) -- (ADD1.blpin 2);

        \node[left=0.25cm] (FOUR) at (ADD2.blpin 2) {\ttfamily\scriptsize 4};
        \draw (FOUR.east) -- (ADD2.blpin 2);
    \end{tikzpicture}
    \caption{Full Datapath.}
\end{figure}
